---
layout: post
title: Java I/O简单了解
categories: Java
description: 
keywords: Java, I/O
---

## Java I/O

本文接[一天一个设计模式(装饰器模式)](/_posts/2019-10-16-decorator-pattern.md)一文继续深入了解Java I/O体系

> java.io下的类数量繁多,记得第一次试图尝试研究一下java io源码时,无从下手,最近在接触了一些设计模式后在重新梳理研究一下Java I/O, 以此记录.

- **输入**

  **InputStream**(This abstract class is the superclass of all classes representing an input stream of `bytes`)

  |输入源|对应的具体类|构造方法参数及说明|
  |-|-|-|
  |字节数组|ByteArrayInputStream|一个byte[]数组
  |String|StringBufferedInputStream|以弃用
  |文件|FileInputStream|String, File, FileDescriptor, 指从一个文件中读取信息
  |*管道*|PipedInputStream|可以想象成实际中的管道,你把一些东西从管子一头放入,而他们将从另一头出来
  |其他输入流的组合序列|SequenceInputStream|用来表示逻辑的*串联流*(指任意其他InputStream)
  |其他数据源|网络|
  
  ```java
  package java.io;
  public abstract class InputStream implements Closeable {

    private static final int MAX_SKIP_BUFFER_SIZE = 2048;

    //这是所有子类必须实现的方法,如果在学Java时习惯了System.in, System.out
    //时,一开始时很难进入到一个抽象的思维中的(对我来说),所以一开始并没有理解这个
    //read().
    //以目前理解整理一下:
    //InputStream代表一个可以读的*信息载体*, 当需要从中读入一些信息(如字节,字符)时
    //调用在其上的read()方法,这个方法返回一个int类型的数据
    //  byte[] buf = new byte[]{0x11, 0x23};
    //  ByteArrayInputStream in = new ByteArrayInputStream(buf);
    //  System.out.println(in.read());
    //  其输出结果回返回17(0x11)
    public abstract int read() throws IOException;

    public int read(byte b[]) throws IOException {
        return read(b, 0, b.length);
    }

    public int read(byte b[], int off, int len) throws IOException {
        if (b == null) {
            throw new NullPointerException();
        } else if (off < 0 || len < 0 || len > b.length - off) {
            throw new IndexOutOfBoundsException();
        } else if (len == 0) {
            return 0;
        }

        int c = read();
        if (c == -1) {
            return -1;
        }
        b[off] = (byte)c;

        int i = 1;
        try {
            for (; i < len ; i++) {
                c = read();
                if (c == -1) {
                    break;
                }
                b[off + i] = (byte)c;
            }
        } catch (IOException ee) {
        }
        return i;
    }

    public long skip(long n) throws IOException {

        long remaining = n;
        int nr;

        if (n <= 0) {
            return 0;
        }

        int size = (int)Math.min(MAX_SKIP_BUFFER_SIZE, remaining);
        byte[] skipBuffer = new byte[size];
        while (remaining > 0) {
            nr = read(skipBuffer, 0, (int)Math.min(size, remaining));
            if (nr < 0) {
                break;
            }
            remaining -= nr;
        }

        return n - remaining;
    }

    public int available() throws IOException {
        return 0;
    }

    public void close() throws IOException {}

    public synchronized void mark(int readlimit) {}

    public synchronized void reset() throws IOException {
        throw new IOException("mark/reset not supported");
    }

    public boolean markSupported() {
        return false;
    }
  }
  ```